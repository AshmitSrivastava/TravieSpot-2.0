import {
  __commonJS,
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/save-svg-as-png/lib/saveSvgAsPng.js
var require_saveSvgAsPng = __commonJS({
  "node_modules/save-svg-as-png/lib/saveSvgAsPng.js"(exports) {
    "use strict";
    (function() {
      var out$ = typeof exports != "undefined" && exports || typeof define != "undefined" && {} || this || window;
      if (typeof define !== "undefined")
        define("save-svg-as-png", [], function() {
          return out$;
        });
      out$.default = out$;
      var xmlNs = "http://www.w3.org/2000/xmlns/";
      var xhtmlNs = "http://www.w3.org/1999/xhtml";
      var svgNs = "http://www.w3.org/2000/svg";
      var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" [<!ENTITY nbsp "&#160;">]>';
      var urlRegex = /url\(["']?(.+?)["']?\)/;
      var fontFormats = {
        woff2: "font/woff2",
        woff: "font/woff",
        otf: "application/x-font-opentype",
        ttf: "application/x-font-ttf",
        eot: "application/vnd.ms-fontobject",
        sfnt: "application/font-sfnt",
        svg: "image/svg+xml"
      };
      var isElement = function isElement2(obj) {
        return obj instanceof HTMLElement || obj instanceof SVGElement;
      };
      var requireDomNode = function requireDomNode2(el) {
        if (!isElement(el))
          throw new Error("an HTMLElement or SVGElement is required; got " + el);
      };
      var requireDomNodePromise = function requireDomNodePromise2(el) {
        return new Promise(function(resolve, reject) {
          if (isElement(el))
            resolve(el);
          else
            reject(new Error("an HTMLElement or SVGElement is required; got " + el));
        });
      };
      var isExternal = function isExternal2(url) {
        return url && url.lastIndexOf("http", 0) === 0 && url.lastIndexOf(window.location.host) === -1;
      };
      var getFontMimeTypeFromUrl = function getFontMimeTypeFromUrl2(fontUrl) {
        var formats = Object.keys(fontFormats).filter(function(extension) {
          return fontUrl.indexOf("." + extension) > 0;
        }).map(function(extension) {
          return fontFormats[extension];
        });
        if (formats)
          return formats[0];
        console.error("Unknown font format for " + fontUrl + ". Fonts may not be working correctly.");
        return "application/octet-stream";
      };
      var arrayBufferToBase64 = function arrayBufferToBase642(buffer) {
        var binary = "";
        var bytes = new Uint8Array(buffer);
        for (var i2 = 0; i2 < bytes.byteLength; i2++) {
          binary += String.fromCharCode(bytes[i2]);
        }
        return window.btoa(binary);
      };
      var getDimension = function getDimension2(el, clone, dim) {
        var v2 = el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim] || clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim)) || el.getBoundingClientRect()[dim] || parseInt(clone.style[dim]) || parseInt(window.getComputedStyle(el).getPropertyValue(dim));
        return typeof v2 === "undefined" || v2 === null || isNaN(parseFloat(v2)) ? 0 : v2;
      };
      var getDimensions = function getDimensions2(el, clone, width, height) {
        if (el.tagName === "svg")
          return {
            width: width || getDimension(el, clone, "width"),
            height: height || getDimension(el, clone, "height")
          };
        else if (el.getBBox) {
          var _el$getBBox = el.getBBox(), x = _el$getBBox.x, y2 = _el$getBBox.y, _width = _el$getBBox.width, _height = _el$getBBox.height;
          return {
            width: x + _width,
            height: y2 + _height
          };
        }
      };
      var reEncode = function reEncode2(data) {
        return decodeURIComponent(encodeURIComponent(data).replace(/%([0-9A-F]{2})/g, function(match, p1) {
          var c2 = String.fromCharCode("0x" + p1);
          return c2 === "%" ? "%25" : c2;
        }));
      };
      var uriToBlob = function uriToBlob2(uri) {
        var byteString = window.atob(uri.split(",")[1]);
        var mimeString = uri.split(",")[0].split(":")[1].split(";")[0];
        var buffer = new ArrayBuffer(byteString.length);
        var intArray = new Uint8Array(buffer);
        for (var i2 = 0; i2 < byteString.length; i2++) {
          intArray[i2] = byteString.charCodeAt(i2);
        }
        return new Blob([buffer], { type: mimeString });
      };
      var query = function query2(el, selector) {
        if (!selector)
          return;
        try {
          return el.querySelector(selector) || el.parentNode && el.parentNode.querySelector(selector);
        } catch (err) {
          console.warn('Invalid CSS selector "' + selector + '"', err);
        }
      };
      var detectCssFont = function detectCssFont2(rule, href) {
        var match = rule.cssText.match(urlRegex);
        var url = match && match[1] || "";
        if (!url || url.match(/^data:/) || url === "about:blank")
          return;
        var fullUrl = url.startsWith("../") ? href + "/../" + url : url.startsWith("./") ? href + "/." + url : url;
        return {
          text: rule.cssText,
          format: getFontMimeTypeFromUrl(fullUrl),
          url: fullUrl
        };
      };
      var inlineImages = function inlineImages2(el) {
        return Promise.all(Array.from(el.querySelectorAll("image")).map(function(image) {
          var href = image.getAttributeNS("http://www.w3.org/1999/xlink", "href") || image.getAttribute("href");
          if (!href)
            return Promise.resolve(null);
          if (isExternal(href)) {
            href += (href.indexOf("?") === -1 ? "?" : "&") + "t=" + (/* @__PURE__ */ new Date()).valueOf();
          }
          return new Promise(function(resolve, reject) {
            var canvas = document.createElement("canvas");
            var img = new Image();
            img.crossOrigin = "anonymous";
            img.src = href;
            img.onerror = function() {
              return reject(new Error("Could not load " + href));
            };
            img.onload = function() {
              canvas.width = img.width;
              canvas.height = img.height;
              canvas.getContext("2d").drawImage(img, 0, 0);
              image.setAttributeNS("http://www.w3.org/1999/xlink", "href", canvas.toDataURL("image/png"));
              resolve(true);
            };
          });
        }));
      };
      var cachedFonts = {};
      var inlineFonts = function inlineFonts2(fonts) {
        return Promise.all(fonts.map(function(font) {
          return new Promise(function(resolve, reject) {
            if (cachedFonts[font.url])
              return resolve(cachedFonts[font.url]);
            var req = new XMLHttpRequest();
            req.addEventListener("load", function() {
              var fontInBase64 = arrayBufferToBase64(req.response);
              var fontUri = font.text.replace(urlRegex, 'url("data:' + font.format + ";base64," + fontInBase64 + '")') + "\n";
              cachedFonts[font.url] = fontUri;
              resolve(fontUri);
            });
            req.addEventListener("error", function(e) {
              console.warn("Failed to load font from: " + font.url, e);
              cachedFonts[font.url] = null;
              resolve(null);
            });
            req.addEventListener("abort", function(e) {
              console.warn("Aborted loading font from: " + font.url, e);
              resolve(null);
            });
            req.open("GET", font.url);
            req.responseType = "arraybuffer";
            req.send();
          });
        })).then(function(fontCss) {
          return fontCss.filter(function(x) {
            return x;
          }).join("");
        });
      };
      var cachedRules = null;
      var styleSheetRules = function styleSheetRules2() {
        if (cachedRules)
          return cachedRules;
        return cachedRules = Array.from(document.styleSheets).map(function(sheet) {
          try {
            return { rules: sheet.cssRules, href: sheet.href };
          } catch (e) {
            console.warn("Stylesheet could not be loaded: " + sheet.href, e);
            return {};
          }
        });
      };
      var inlineCss = function inlineCss2(el, options) {
        var _ref = options || {}, selectorRemap = _ref.selectorRemap, modifyStyle = _ref.modifyStyle, modifyCss = _ref.modifyCss, fonts = _ref.fonts, excludeUnusedCss = _ref.excludeUnusedCss;
        var generateCss = modifyCss || function(selector, properties) {
          var sel = selectorRemap ? selectorRemap(selector) : selector;
          var props = modifyStyle ? modifyStyle(properties) : properties;
          return sel + "{" + props + "}\n";
        };
        var css = [];
        var detectFonts = typeof fonts === "undefined";
        var fontList = fonts || [];
        styleSheetRules().forEach(function(_ref2) {
          var rules = _ref2.rules, href = _ref2.href;
          if (!rules)
            return;
          Array.from(rules).forEach(function(rule) {
            if (typeof rule.style != "undefined") {
              if (query(el, rule.selectorText))
                css.push(generateCss(rule.selectorText, rule.style.cssText));
              else if (detectFonts && rule.cssText.match(/^@font-face/)) {
                var font = detectCssFont(rule, href);
                if (font)
                  fontList.push(font);
              } else if (!excludeUnusedCss) {
                css.push(rule.cssText);
              }
            }
          });
        });
        return inlineFonts(fontList).then(function(fontCss) {
          return css.join("\n") + fontCss;
        });
      };
      var downloadOptions = function downloadOptions2() {
        if (!navigator.msSaveOrOpenBlob && !("download" in document.createElement("a"))) {
          return { popup: window.open() };
        }
      };
      out$.prepareSvg = function(el, options, done) {
        requireDomNode(el);
        var _ref3 = options || {}, _ref3$left = _ref3.left, left = _ref3$left === void 0 ? 0 : _ref3$left, _ref3$top = _ref3.top, top = _ref3$top === void 0 ? 0 : _ref3$top, w2 = _ref3.width, h2 = _ref3.height, _ref3$scale = _ref3.scale, scale = _ref3$scale === void 0 ? 1 : _ref3$scale, _ref3$responsive = _ref3.responsive, responsive = _ref3$responsive === void 0 ? false : _ref3$responsive, _ref3$excludeCss = _ref3.excludeCss, excludeCss = _ref3$excludeCss === void 0 ? false : _ref3$excludeCss;
        return inlineImages(el).then(function() {
          var clone = el.cloneNode(true);
          clone.style.backgroundColor = (options || {}).backgroundColor || el.style.backgroundColor;
          var _getDimensions = getDimensions(el, clone, w2, h2), width = _getDimensions.width, height = _getDimensions.height;
          if (el.tagName !== "svg") {
            if (el.getBBox) {
              if (clone.getAttribute("transform") != null) {
                clone.setAttribute("transform", clone.getAttribute("transform").replace(/translate\(.*?\)/, ""));
              }
              var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              svg.appendChild(clone);
              clone = svg;
            } else {
              console.error("Attempted to render non-SVG element", el);
              return;
            }
          }
          clone.setAttribute("version", "1.1");
          clone.setAttribute("viewBox", [left, top, width, height].join(" "));
          if (!clone.getAttribute("xmlns"))
            clone.setAttributeNS(xmlNs, "xmlns", svgNs);
          if (!clone.getAttribute("xmlns:xlink"))
            clone.setAttributeNS(xmlNs, "xmlns:xlink", "http://www.w3.org/1999/xlink");
          if (responsive) {
            clone.removeAttribute("width");
            clone.removeAttribute("height");
            clone.setAttribute("preserveAspectRatio", "xMinYMin meet");
          } else {
            clone.setAttribute("width", width * scale);
            clone.setAttribute("height", height * scale);
          }
          Array.from(clone.querySelectorAll("foreignObject > *")).forEach(function(foreignObject) {
            foreignObject.setAttributeNS(xmlNs, "xmlns", foreignObject.tagName === "svg" ? svgNs : xhtmlNs);
          });
          if (excludeCss) {
            var outer = document.createElement("div");
            outer.appendChild(clone);
            var src = outer.innerHTML;
            if (typeof done === "function")
              done(src, width, height);
            else
              return { src, width, height };
          } else {
            return inlineCss(el, options).then(function(css) {
              var style = document.createElement("style");
              style.setAttribute("type", "text/css");
              style.innerHTML = "<![CDATA[\n" + css + "\n]]>";
              var defs = document.createElement("defs");
              defs.appendChild(style);
              clone.insertBefore(defs, clone.firstChild);
              var outer2 = document.createElement("div");
              outer2.appendChild(clone);
              var src2 = outer2.innerHTML.replace(/NS\d+:href/gi, 'xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href');
              if (typeof done === "function")
                done(src2, width, height);
              else
                return { src: src2, width, height };
            });
          }
        });
      };
      out$.svgAsDataUri = function(el, options, done) {
        requireDomNode(el);
        return out$.prepareSvg(el, options).then(function(_ref4) {
          var src = _ref4.src, width = _ref4.width, height = _ref4.height;
          var svgXml = "data:image/svg+xml;base64," + window.btoa(reEncode(doctype + src));
          if (typeof done === "function") {
            done(svgXml, width, height);
          }
          return svgXml;
        });
      };
      out$.svgAsPngUri = function(el, options, done) {
        requireDomNode(el);
        var _ref5 = options || {}, _ref5$encoderType = _ref5.encoderType, encoderType = _ref5$encoderType === void 0 ? "image/png" : _ref5$encoderType, _ref5$encoderOptions = _ref5.encoderOptions, encoderOptions = _ref5$encoderOptions === void 0 ? 0.8 : _ref5$encoderOptions, canvg = _ref5.canvg;
        var convertToPng = function convertToPng2(_ref6) {
          var src = _ref6.src, width = _ref6.width, height = _ref6.height;
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          var pixelRatio = window.devicePixelRatio || 1;
          canvas.width = width * pixelRatio;
          canvas.height = height * pixelRatio;
          canvas.style.width = canvas.width + "px";
          canvas.style.height = canvas.height + "px";
          context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          if (canvg)
            canvg(canvas, src);
          else
            context.drawImage(src, 0, 0);
          var png = void 0;
          try {
            png = canvas.toDataURL(encoderType, encoderOptions);
          } catch (e) {
            if (typeof SecurityError !== "undefined" && e instanceof SecurityError || e.name === "SecurityError") {
              console.error("Rendered SVG images cannot be downloaded in this browser.");
              return;
            } else
              throw e;
          }
          if (typeof done === "function")
            done(png, canvas.width, canvas.height);
          return Promise.resolve(png);
        };
        if (canvg)
          return out$.prepareSvg(el, options).then(convertToPng);
        else
          return out$.svgAsDataUri(el, options).then(function(uri) {
            return new Promise(function(resolve, reject) {
              var image = new Image();
              image.onload = function() {
                return resolve(convertToPng({
                  src: image,
                  width: image.width,
                  height: image.height
                }));
              };
              image.onerror = function() {
                reject("There was an error loading the data URI as an image on the following SVG\n" + window.atob(uri.slice(26)) + "Open the following link to see browser's diagnosis\n" + uri);
              };
              image.src = uri;
            });
          });
      };
      out$.download = function(name, uri, options) {
        if (navigator.msSaveOrOpenBlob)
          navigator.msSaveOrOpenBlob(uriToBlob(uri), name);
        else {
          var saveLink = document.createElement("a");
          if ("download" in saveLink) {
            saveLink.download = name;
            saveLink.style.display = "none";
            document.body.appendChild(saveLink);
            try {
              var blob = uriToBlob(uri);
              var url = URL.createObjectURL(blob);
              saveLink.href = url;
              saveLink.onclick = function() {
                return requestAnimationFrame(function() {
                  return URL.revokeObjectURL(url);
                });
              };
            } catch (e) {
              console.error(e);
              console.warn("Error while getting object URL. Falling back to string URL.");
              saveLink.href = uri;
            }
            saveLink.click();
            document.body.removeChild(saveLink);
          } else if (options && options.popup) {
            options.popup.document.title = name;
            options.popup.location.replace(uri);
          }
        }
      };
      out$.saveSvg = function(el, name, options) {
        var downloadOpts = downloadOptions();
        return requireDomNodePromise(el).then(function(el2) {
          return out$.svgAsDataUri(el2, options || {});
        }).then(function(uri) {
          return out$.download(name, uri, downloadOpts);
        });
      };
      out$.saveSvgAsPng = function(el, name, options) {
        var downloadOpts = downloadOptions();
        return requireDomNodePromise(el).then(function(el2) {
          return out$.svgAsPngUri(el2, options || {});
        }).then(function(uri) {
          return out$.download(name, uri, downloadOpts);
        });
      };
    })();
  }
});

// node_modules/file-saver/dist/FileSaver.min.js
var require_FileSaver_min = __commonJS({
  "node_modules/file-saver/dist/FileSaver.min.js"(exports, module) {
    (function(a2, b2) {
      if ("function" == typeof define && define.amd)
        define([], b2);
      else if ("undefined" != typeof exports)
        b2();
      else {
        b2(), a2.FileSaver = { exports: {} }.exports;
      }
    })(exports, function() {
      "use strict";
      function b2(a3, b3) {
        return "undefined" == typeof b3 ? b3 = { autoBom: false } : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
      }
      function c2(a3, b3, c3) {
        var d3 = new XMLHttpRequest();
        d3.open("GET", a3), d3.responseType = "blob", d3.onload = function() {
          g2(d3.response, b3, c3);
        }, d3.onerror = function() {
          console.error("could not download file");
        }, d3.send();
      }
      function d2(a3) {
        var b3 = new XMLHttpRequest();
        b3.open("HEAD", a3, false);
        try {
          b3.send();
        } catch (a4) {
        }
        return 200 <= b3.status && 299 >= b3.status;
      }
      function e(a3) {
        try {
          a3.dispatchEvent(new MouseEvent("click"));
        } catch (c3) {
          var b3 = document.createEvent("MouseEvents");
          b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
        }
      }
      var f2 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || ("object" != typeof window || window !== f2 ? function() {
      } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {
        var i2 = f2.URL || f2.webkitURL, j = document.createElement("a");
        g3 = g3 || b3.name || "download", j.download = g3, j.rel = "noopener", "string" == typeof b3 ? (j.href = b3, j.origin === location.origin ? e(j) : d2(j.href) ? c2(b3, g3, h2) : e(j, j.target = "_blank")) : (j.href = i2.createObjectURL(b3), setTimeout(function() {
          i2.revokeObjectURL(j.href);
        }, 4e4), setTimeout(function() {
          e(j);
        }, 0));
      } : "msSaveOrOpenBlob" in navigator ? function(f3, g3, h2) {
        if (g3 = g3 || f3.name || "download", "string" != typeof f3)
          navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
        else if (d2(f3))
          c2(f3, g3, h2);
        else {
          var i2 = document.createElement("a");
          i2.href = f3, i2.target = "_blank", setTimeout(function() {
            e(i2);
          });
        }
      } : function(b3, d3, e2, g3) {
        if (g3 = g3 || open("", "_blank"), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), "string" == typeof b3)
          return c2(b3, d3, e2);
        var h2 = "application/octet-stream" === b3.type, i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h2 && i2 || a2) && "undefined" != typeof FileReader) {
          var k = new FileReader();
          k.onloadend = function() {
            var a3 = k.result;
            a3 = j ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g3 ? g3.location.href = a3 : location = a3, g3 = null;
          }, k.readAsDataURL(b3);
        } else {
          var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);
          g3 ? g3.location = m2 : location.href = m2, g3 = null, setTimeout(function() {
            l2.revokeObjectURL(m2);
          }, 4e4);
        }
      });
      f2.saveAs = g2.saveAs = g2, "undefined" != typeof module && (module.exports = g2);
    });
  }
});

// node_modules/html-to-image/es/util.js
function resolveUrl(url, baseUrl) {
  if (url.match(/^[a-z]+:\/\//i)) {
    return url;
  }
  if (url.match(/^\/\//)) {
    return window.location.protocol + url;
  }
  if (url.match(/^[a-z]+:/i)) {
    return url;
  }
  const doc = document.implementation.createHTMLDocument();
  const base = doc.createElement("base");
  const a2 = doc.createElement("a");
  doc.head.appendChild(base);
  doc.body.appendChild(a2);
  if (baseUrl) {
    base.href = baseUrl;
  }
  a2.href = url;
  return a2.href;
}
var uuid = /* @__PURE__ */ (() => {
  let counter = 0;
  const random = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => {
    counter += 1;
    return `u${random()}${counter}`;
  };
})();
function toArray(arrayLike) {
  const arr = [];
  for (let i2 = 0, l2 = arrayLike.length; i2 < l2; i2++) {
    arr.push(arrayLike[i2]);
  }
  return arr;
}
function px(node, styleProperty) {
  const win = node.ownerDocument.defaultView || window;
  const val = win.getComputedStyle(node).getPropertyValue(styleProperty);
  return val ? parseFloat(val.replace("px", "")) : 0;
}
function getNodeWidth(node) {
  const leftBorder = px(node, "border-left-width");
  const rightBorder = px(node, "border-right-width");
  return node.clientWidth + leftBorder + rightBorder;
}
function getNodeHeight(node) {
  const topBorder = px(node, "border-top-width");
  const bottomBorder = px(node, "border-bottom-width");
  return node.clientHeight + topBorder + bottomBorder;
}
function getImageSize(targetNode, options = {}) {
  const width = options.width || getNodeWidth(targetNode);
  const height = options.height || getNodeHeight(targetNode);
  return { width, height };
}
function getPixelRatio() {
  let ratio;
  let FINAL_PROCESS;
  try {
    FINAL_PROCESS = process;
  } catch (e) {
  }
  const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
  if (val) {
    ratio = parseInt(val, 10);
    if (Number.isNaN(ratio)) {
      ratio = 1;
    }
  }
  return ratio || window.devicePixelRatio || 1;
}
var canvasDimensionLimit = 16384;
function checkCanvasDimensions(canvas) {
  if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
    if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
      if (canvas.width > canvas.height) {
        canvas.height *= canvasDimensionLimit / canvas.width;
        canvas.width = canvasDimensionLimit;
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height;
        canvas.height = canvasDimensionLimit;
      }
    } else if (canvas.width > canvasDimensionLimit) {
      canvas.height *= canvasDimensionLimit / canvas.width;
      canvas.width = canvasDimensionLimit;
    } else {
      canvas.width *= canvasDimensionLimit / canvas.height;
      canvas.height = canvasDimensionLimit;
    }
  }
}
function createImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.decode = () => resolve(img);
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.crossOrigin = "anonymous";
    img.decoding = "async";
    img.src = url;
  });
}
async function svgToDataURL(svg) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
}
async function nodeToDataURL(node, width, height) {
  const xmlns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(xmlns, "svg");
  const foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg.setAttribute("width", `${width}`);
  svg.setAttribute("height", `${height}`);
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  foreignObject.setAttribute("width", "100%");
  foreignObject.setAttribute("height", "100%");
  foreignObject.setAttribute("x", "0");
  foreignObject.setAttribute("y", "0");
  foreignObject.setAttribute("externalResourcesRequired", "true");
  svg.appendChild(foreignObject);
  foreignObject.appendChild(node);
  return svgToDataURL(svg);
}
var isInstanceOfElement = (node, instance) => {
  if (node instanceof instance)
    return true;
  const nodePrototype = Object.getPrototypeOf(node);
  if (nodePrototype === null)
    return false;
  return nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);
};

// node_modules/html-to-image/es/clone-pseudos.js
function formatCSSText(style) {
  const content = style.getPropertyValue("content");
  return `${style.cssText} content: '${content.replace(/'|"/g, "")}';`;
}
function formatCSSProperties(style) {
  return toArray(style).map((name) => {
    const value = style.getPropertyValue(name);
    const priority = style.getPropertyPriority(name);
    return `${name}: ${value}${priority ? " !important" : ""};`;
  }).join(" ");
}
function getPseudoElementStyle(className, pseudo, style) {
  const selector = `.${className}:${pseudo}`;
  const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style);
  return document.createTextNode(`${selector}{${cssText}}`);
}
function clonePseudoElement(nativeNode, clonedNode, pseudo) {
  const style = window.getComputedStyle(nativeNode, pseudo);
  const content = style.getPropertyValue("content");
  if (content === "" || content === "none") {
    return;
  }
  const className = uuid();
  try {
    clonedNode.className = `${clonedNode.className} ${className}`;
  } catch (err) {
    return;
  }
  const styleElement = document.createElement("style");
  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
  clonedNode.appendChild(styleElement);
}
function clonePseudoElements(nativeNode, clonedNode) {
  clonePseudoElement(nativeNode, clonedNode, ":before");
  clonePseudoElement(nativeNode, clonedNode, ":after");
}

// node_modules/html-to-image/es/mimes.js
var WOFF = "application/font-woff";
var JPEG = "image/jpeg";
var mimes = {
  woff: WOFF,
  woff2: WOFF,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: JPEG,
  jpeg: JPEG,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function getExtension(url) {
  const match = /\.([^./]*?)$/g.exec(url);
  return match ? match[1] : "";
}
function getMimeType(url) {
  const extension = getExtension(url).toLowerCase();
  return mimes[extension] || "";
}

// node_modules/html-to-image/es/dataurl.js
function getContentFromDataUrl(dataURL) {
  return dataURL.split(/,/)[1];
}
function isDataUrl(url) {
  return url.search(/^(data:)/) !== -1;
}
function makeDataUrl(content, mimeType) {
  return `data:${mimeType};base64,${content}`;
}
async function fetchAsDataURL(url, init, process2) {
  const res = await fetch(url, init);
  if (res.status === 404) {
    throw new Error(`Resource "${res.url}" not found`);
  }
  const blob = await res.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onloadend = () => {
      try {
        resolve(process2({ res, result: reader.result }));
      } catch (error) {
        reject(error);
      }
    };
    reader.readAsDataURL(blob);
  });
}
var cache = {};
function getCacheKey(url, contentType, includeQueryParams) {
  let key = url.replace(/\?.*/, "");
  if (includeQueryParams) {
    key = url;
  }
  if (/ttf|otf|eot|woff2?/i.test(key)) {
    key = key.replace(/.*\//, "");
  }
  return contentType ? `[${contentType}]${key}` : key;
}
async function resourceToDataURL(resourceUrl, contentType, options) {
  const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
  if (cache[cacheKey] != null) {
    return cache[cacheKey];
  }
  if (options.cacheBust) {
    resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
  }
  let dataURL;
  try {
    const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => {
      if (!contentType) {
        contentType = res.headers.get("Content-Type") || "";
      }
      return getContentFromDataUrl(result);
    });
    dataURL = makeDataUrl(content, contentType);
  } catch (error) {
    dataURL = options.imagePlaceholder || "";
    let msg = `Failed to fetch resource: ${resourceUrl}`;
    if (error) {
      msg = typeof error === "string" ? error : error.message;
    }
    if (msg) {
      console.warn(msg);
    }
  }
  cache[cacheKey] = dataURL;
  return dataURL;
}

// node_modules/html-to-image/es/clone-node.js
async function cloneCanvasElement(canvas) {
  const dataURL = canvas.toDataURL();
  if (dataURL === "data:,") {
    return canvas.cloneNode(false);
  }
  return createImage(dataURL);
}
async function cloneVideoElement(video, options) {
  if (video.currentSrc) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = video.clientWidth;
    canvas.height = video.clientHeight;
    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const dataURL2 = canvas.toDataURL();
    return createImage(dataURL2);
  }
  const poster = video.poster;
  const contentType = getMimeType(poster);
  const dataURL = await resourceToDataURL(poster, contentType, options);
  return createImage(dataURL);
}
async function cloneIFrameElement(iframe) {
  var _a;
  try {
    if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {
      return await cloneNode(iframe.contentDocument.body, {}, true);
    }
  } catch (_b) {
  }
  return iframe.cloneNode(false);
}
async function cloneSingleNode(node, options) {
  if (isInstanceOfElement(node, HTMLCanvasElement)) {
    return cloneCanvasElement(node);
  }
  if (isInstanceOfElement(node, HTMLVideoElement)) {
    return cloneVideoElement(node, options);
  }
  if (isInstanceOfElement(node, HTMLIFrameElement)) {
    return cloneIFrameElement(node);
  }
  return node.cloneNode(false);
}
var isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SLOT";
async function cloneChildren(nativeNode, clonedNode, options) {
  var _a, _b;
  let children = [];
  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
    children = toArray(nativeNode.assignedNodes());
  } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
    children = toArray(nativeNode.contentDocument.body.childNodes);
  } else {
    children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);
  }
  if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {
    return clonedNode;
  }
  await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options)).then((clonedChild) => {
    if (clonedChild) {
      clonedNode.appendChild(clonedChild);
    }
  }), Promise.resolve());
  return clonedNode;
}
function cloneCSSStyle(nativeNode, clonedNode) {
  const targetStyle = clonedNode.style;
  if (!targetStyle) {
    return;
  }
  const sourceStyle = window.getComputedStyle(nativeNode);
  if (sourceStyle.cssText) {
    targetStyle.cssText = sourceStyle.cssText;
    targetStyle.transformOrigin = sourceStyle.transformOrigin;
  } else {
    toArray(sourceStyle).forEach((name) => {
      let value = sourceStyle.getPropertyValue(name);
      if (name === "font-size" && value.endsWith("px")) {
        const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
        value = `${reducedFont}px`;
      }
      if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === "display" && value === "inline") {
        value = "block";
      }
      if (name === "d" && clonedNode.getAttribute("d")) {
        value = `path(${clonedNode.getAttribute("d")})`;
      }
      targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
    });
  }
}
function cloneInputValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
    clonedNode.innerHTML = nativeNode.value;
  }
  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
    clonedNode.setAttribute("value", nativeNode.value);
  }
}
function cloneSelectValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
    const clonedSelect = clonedNode;
    const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute("value"));
    if (selectedOption) {
      selectedOption.setAttribute("selected", "");
    }
  }
}
function decorate(nativeNode, clonedNode) {
  if (isInstanceOfElement(clonedNode, Element)) {
    cloneCSSStyle(nativeNode, clonedNode);
    clonePseudoElements(nativeNode, clonedNode);
    cloneInputValue(nativeNode, clonedNode);
    cloneSelectValue(nativeNode, clonedNode);
  }
  return clonedNode;
}
async function ensureSVGSymbols(clone, options) {
  const uses = clone.querySelectorAll ? clone.querySelectorAll("use") : [];
  if (uses.length === 0) {
    return clone;
  }
  const processedDefs = {};
  for (let i2 = 0; i2 < uses.length; i2++) {
    const use = uses[i2];
    const id = use.getAttribute("xlink:href");
    if (id) {
      const exist = clone.querySelector(id);
      const definition = document.querySelector(id);
      if (!exist && definition && !processedDefs[id]) {
        processedDefs[id] = await cloneNode(definition, options, true);
      }
    }
  }
  const nodes = Object.values(processedDefs);
  if (nodes.length) {
    const ns = "http://www.w3.org/1999/xhtml";
    const svg = document.createElementNS(ns, "svg");
    svg.setAttribute("xmlns", ns);
    svg.style.position = "absolute";
    svg.style.width = "0";
    svg.style.height = "0";
    svg.style.overflow = "hidden";
    svg.style.display = "none";
    const defs = document.createElementNS(ns, "defs");
    svg.appendChild(defs);
    for (let i2 = 0; i2 < nodes.length; i2++) {
      defs.appendChild(nodes[i2]);
    }
    clone.appendChild(svg);
  }
  return clone;
}
async function cloneNode(node, options, isRoot) {
  if (!isRoot && options.filter && !options.filter(node)) {
    return null;
  }
  return Promise.resolve(node).then((clonedNode) => cloneSingleNode(clonedNode, options)).then((clonedNode) => cloneChildren(node, clonedNode, options)).then((clonedNode) => decorate(node, clonedNode)).then((clonedNode) => ensureSVGSymbols(clonedNode, options));
}

// node_modules/html-to-image/es/embed-resources.js
var URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
var URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
var FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function toRegex(url) {
  const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
}
function parseURLs(cssText) {
  const urls = [];
  cssText.replace(URL_REGEX, (raw, quotation, url) => {
    urls.push(url);
    return raw;
  });
  return urls.filter((url) => !isDataUrl(url));
}
async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
  try {
    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
    const contentType = getMimeType(resourceURL);
    let dataURL;
    if (getContentFromUrl) {
      const content = await getContentFromUrl(resolvedURL);
      dataURL = makeDataUrl(content, contentType);
    } else {
      dataURL = await resourceToDataURL(resolvedURL, contentType, options);
    }
    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
  } catch (error) {
  }
  return cssText;
}
function filterPreferredFontFormat(str, { preferredFontFormat }) {
  return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, (match) => {
    while (true) {
      const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
      if (!format) {
        return "";
      }
      if (format === preferredFontFormat) {
        return `src: ${src};`;
      }
    }
  });
}
function shouldEmbed(url) {
  return url.search(URL_REGEX) !== -1;
}
async function embedResources(cssText, baseUrl, options) {
  if (!shouldEmbed(cssText)) {
    return cssText;
  }
  const filteredCSSText = filterPreferredFontFormat(cssText, options);
  const urls = parseURLs(filteredCSSText);
  return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));
}

// node_modules/html-to-image/es/embed-images.js
async function embedProp(propName, node, options) {
  var _a;
  const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);
  if (propValue) {
    const cssString = await embedResources(propValue, null, options);
    node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));
    return true;
  }
  return false;
}
async function embedBackground(clonedNode, options) {
  if (!await embedProp("background", clonedNode, options)) {
    await embedProp("background-image", clonedNode, options);
  }
  if (!await embedProp("mask", clonedNode, options)) {
    await embedProp("mask-image", clonedNode, options);
  }
}
async function embedImageNode(clonedNode, options) {
  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);
  if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {
    return;
  }
  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
  const dataURL = await resourceToDataURL(url, getMimeType(url), options);
  await new Promise((resolve, reject) => {
    clonedNode.onload = resolve;
    clonedNode.onerror = reject;
    const image = clonedNode;
    if (image.decode) {
      image.decode = resolve;
    }
    if (image.loading === "lazy") {
      image.loading = "eager";
    }
    if (isImageElement) {
      clonedNode.srcset = "";
      clonedNode.src = dataURL;
    } else {
      clonedNode.href.baseVal = dataURL;
    }
  });
}
async function embedChildren(clonedNode, options) {
  const children = toArray(clonedNode.childNodes);
  const deferreds = children.map((child) => embedImages(child, options));
  await Promise.all(deferreds).then(() => clonedNode);
}
async function embedImages(clonedNode, options) {
  if (isInstanceOfElement(clonedNode, Element)) {
    await embedBackground(clonedNode, options);
    await embedImageNode(clonedNode, options);
    await embedChildren(clonedNode, options);
  }
}

// node_modules/html-to-image/es/apply-style.js
function applyStyle(node, options) {
  const { style } = node;
  if (options.backgroundColor) {
    style.backgroundColor = options.backgroundColor;
  }
  if (options.width) {
    style.width = `${options.width}px`;
  }
  if (options.height) {
    style.height = `${options.height}px`;
  }
  const manual = options.style;
  if (manual != null) {
    Object.keys(manual).forEach((key) => {
      style[key] = manual[key];
    });
  }
  return node;
}

// node_modules/html-to-image/es/embed-webfonts.js
var cssFetchCache = {};
async function fetchCSS(url) {
  let cache2 = cssFetchCache[url];
  if (cache2 != null) {
    return cache2;
  }
  const res = await fetch(url);
  const cssText = await res.text();
  cache2 = { url, cssText };
  cssFetchCache[url] = cache2;
  return cache2;
}
async function embedFonts(data, options) {
  let cssText = data.cssText;
  const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
  const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
  const loadFonts = fontLocs.map(async (loc) => {
    let url = loc.replace(regexUrl, "$1");
    if (!url.startsWith("https://")) {
      url = new URL(url, data.url).href;
    }
    return fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => {
      cssText = cssText.replace(loc, `url(${result})`);
      return [loc, result];
    });
  });
  return Promise.all(loadFonts).then(() => cssText);
}
function parseCSS(source) {
  if (source == null) {
    return [];
  }
  const result = [];
  const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
  let cssText = source.replace(commentsRegex, "");
  const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  while (true) {
    const matches = keyframesRegex.exec(cssText);
    if (matches === null) {
      break;
    }
    result.push(matches[0]);
  }
  cssText = cssText.replace(keyframesRegex, "");
  const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
  const combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
  const unifiedRegex = new RegExp(combinedCSSRegex, "gi");
  while (true) {
    let matches = importRegex.exec(cssText);
    if (matches === null) {
      matches = unifiedRegex.exec(cssText);
      if (matches === null) {
        break;
      } else {
        importRegex.lastIndex = unifiedRegex.lastIndex;
      }
    } else {
      unifiedRegex.lastIndex = importRegex.lastIndex;
    }
    result.push(matches[0]);
  }
  return result;
}
async function getCSSRules(styleSheets, options) {
  const ret = [];
  const deferreds = [];
  styleSheets.forEach((sheet) => {
    if ("cssRules" in sheet) {
      try {
        toArray(sheet.cssRules || []).forEach((item, index) => {
          if (item.type === CSSRule.IMPORT_RULE) {
            let importIndex = index + 1;
            const url = item.href;
            const deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
              try {
                sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
              } catch (error) {
                console.error("Error inserting rule from remote css", {
                  rule,
                  error
                });
              }
            })).catch((e) => {
              console.error("Error loading remote css", e.toString());
            });
            deferreds.push(deferred);
          }
        });
      } catch (e) {
        const inline = styleSheets.find((a2) => a2.href == null) || document.styleSheets[0];
        if (sheet.href != null) {
          deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
            inline.insertRule(rule, sheet.cssRules.length);
          })).catch((err) => {
            console.error("Error loading remote stylesheet", err);
          }));
        }
        console.error("Error inlining remote css file", e);
      }
    }
  });
  return Promise.all(deferreds).then(() => {
    styleSheets.forEach((sheet) => {
      if ("cssRules" in sheet) {
        try {
          toArray(sheet.cssRules || []).forEach((item) => {
            ret.push(item);
          });
        } catch (e) {
          console.error(`Error while reading CSS rules from ${sheet.href}`, e);
        }
      }
    });
    return ret;
  });
}
function getWebFontRules(cssRules) {
  return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
}
async function parseWebFontRules(node, options) {
  if (node.ownerDocument == null) {
    throw new Error("Provided element is not within a Document");
  }
  const styleSheets = toArray(node.ownerDocument.styleSheets);
  const cssRules = await getCSSRules(styleSheets, options);
  return getWebFontRules(cssRules);
}
async function getWebFontCSS(node, options) {
  const rules = await parseWebFontRules(node, options);
  const cssTexts = await Promise.all(rules.map((rule) => {
    const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
    return embedResources(rule.cssText, baseUrl, options);
  }));
  return cssTexts.join("\n");
}
async function embedWebFonts(clonedNode, options) {
  const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);
  if (cssText) {
    const styleNode = document.createElement("style");
    const sytleContent = document.createTextNode(cssText);
    styleNode.appendChild(sytleContent);
    if (clonedNode.firstChild) {
      clonedNode.insertBefore(styleNode, clonedNode.firstChild);
    } else {
      clonedNode.appendChild(styleNode);
    }
  }
}

// node_modules/html-to-image/es/index.js
async function toSvg(node, options = {}) {
  const { width, height } = getImageSize(node, options);
  const clonedNode = await cloneNode(node, options, true);
  await embedWebFonts(clonedNode, options);
  await embedImages(clonedNode, options);
  applyStyle(clonedNode, options);
  const datauri = await nodeToDataURL(clonedNode, width, height);
  return datauri;
}
async function toCanvas(node, options = {}) {
  const { width, height } = getImageSize(node, options);
  const svg = await toSvg(node, options);
  const img = await createImage(svg);
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  const ratio = options.pixelRatio || getPixelRatio();
  const canvasWidth = options.canvasWidth || width;
  const canvasHeight = options.canvasHeight || height;
  canvas.width = canvasWidth * ratio;
  canvas.height = canvasHeight * ratio;
  if (!options.skipAutoScale) {
    checkCanvasDimensions(canvas);
  }
  canvas.style.width = `${canvasWidth}`;
  canvas.style.height = `${canvasHeight}`;
  if (options.backgroundColor) {
    context.fillStyle = options.backgroundColor;
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  context.drawImage(img, 0, 0, canvas.width, canvas.height);
  return canvas;
}
async function toPng(node, options = {}) {
  const canvas = await toCanvas(node, options);
  return canvas.toDataURL();
}
async function toJpeg(node, options = {}) {
  const canvas = await toCanvas(node, options);
  return canvas.toDataURL("image/jpeg", options.quality || 1);
}

// node_modules/save-html-as-image/dist/index.modern.js
var import_save_svg_as_png = __toESM(require_saveSvgAsPng());
var import_file_saver = __toESM(require_FileSaver_min());
function o() {
  return (o = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n2 = arguments[e];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (t[r2] = n2[r2]);
    }
    return t;
  }).apply(this, arguments);
}
function i(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var n2 = 0, r2 = new Array(e); n2 < e; n2++)
    r2[n2] = t[n2];
  return r2;
}
function u(t, e) {
  var n2;
  if ("undefined" == typeof Symbol || null == t[Symbol.iterator]) {
    if (Array.isArray(t) || (n2 = function(t2, e2) {
      if (t2) {
        if ("string" == typeof t2)
          return i(t2, e2);
        var n3 = Object.prototype.toString.call(t2).slice(8, -1);
        return "Object" === n3 && t2.constructor && (n3 = t2.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t2) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? i(t2, e2) : void 0;
      }
    }(t)) || e && t && "number" == typeof t.length) {
      n2 && (t = n2);
      var r2 = 0;
      return function() {
        return r2 >= t.length ? { done: true } : { done: false, value: t[r2++] };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  return (n2 = t[Symbol.iterator]()).next.bind(n2);
}
var a = "undefined" != typeof Symbol ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
function l(t, e, n2) {
  if (!t.s) {
    if (n2 instanceof c) {
      if (!n2.s)
        return void (n2.o = l.bind(null, t, e));
      1 & e && (e = n2.s), n2 = n2.v;
    }
    if (n2 && n2.then)
      return void n2.then(l.bind(null, t, e), l.bind(null, t, 2));
    t.s = e, t.v = n2;
    var r2 = t.o;
    r2 && r2(t);
  }
}
var c = function() {
  function t() {
  }
  return t.prototype.then = function(e, n2) {
    var r2 = new t(), o2 = this.s;
    if (o2) {
      var i2 = 1 & o2 ? e : n2;
      if (i2) {
        try {
          l(r2, 1, i2(this.v));
        } catch (t2) {
          l(r2, 2, t2);
        }
        return r2;
      }
      return this;
    }
    return this.o = function(t2) {
      try {
        var o3 = t2.v;
        1 & t2.s ? l(r2, 1, e ? e(o3) : o3) : n2 ? l(r2, 1, n2(o3)) : l(r2, 2, o3);
      } catch (t3) {
        l(r2, 2, t3);
      }
    }, r2;
  }, t;
}();
function f(t) {
  return t instanceof c && 1 & t.s;
}
var h = { filename: "Image", forceFixText: false, printDate: true };
var d = function(t) {
  var e = window.getComputedStyle(t);
  t.style.color = e.color;
};
var s = function(t) {
  var e = window.getComputedStyle(t);
  t.style.width = e.width, t.style.height = e.height;
};
var v = function(t, e) {
  void 0 === e && (e = ["b", "h1", "h2", "h3", "h4", "h5", "h6", "i", "mark", "p", "small", "strong"]);
  for (var n2, r2 = u(t.querySelectorAll(e)); !(n2 = r2()).done; ) {
    var o2 = n2.value;
    o2.style.fontFamily = window.getComputedStyle(o2).fontFamily, o2.style.fontSize = window.getComputedStyle(o2).fontSize, o2.style.fontWeight = window.getComputedStyle(o2).fontWeight, o2.style.width = window.getComputedStyle(o2).width;
  }
};
var y = function(t) {
  return "hide-when-downloading" !== t.className;
};
var m = function(t, e, i2, y2) {
  void 0 === y2 && (y2 = "png");
  try {
    var m2 = function() {
      !function(t2) {
        for (var e2, n2 = u(t2.querySelectorAll([".remove-when-downloading"])); !(e2 = n2()).done; ) {
          var r2 = e2.value;
          r2.style.display = r2.getAttribute("original_display");
        }
      }(t), (0, import_file_saver.saveAs)(g2, function(t2) {
        if (t2.printDate) {
          var e2 = (/* @__PURE__ */ new Date()).toDateString();
          return t2.filename + " (" + e2 + ")";
        }
        return t2.filename || "Image";
      }(p2) + "." + y2);
    }, p2 = function(t2) {
      return o({}, h, t2);
    }(e || {}), g2 = null;
    (function(t2, e2) {
      void 0 === e2 && (e2 = false);
      var n2 = t2.querySelectorAll("svg");
      !function(t3) {
        v(t3, [".fixed-text"]);
      }(t2), e2 && v(t2);
      for (var r2, o2 = u(n2); !(r2 = o2()).done; ) {
        var i3 = r2.value;
        d(i3), s(i3);
      }
    })(t, p2.forceFixText), function(t2) {
      for (var e2, n2 = u(t2.querySelectorAll([".remove-when-downloading"])); !(e2 = n2()).done; ) {
        var r2 = e2.value;
        r2.setAttribute("original_display", window.getComputedStyle(r2).display), r2.style.display = "none";
      }
    }(t);
    var w2 = function(t2, e2) {
      try {
        var n2 = Promise.resolve(i2()).then(function(t3) {
          g2 = t3;
        });
      } catch (t3) {
        return e2();
      }
      return n2 && n2.then ? n2.then(void 0, e2) : n2;
    }(0, function() {
      return Promise.resolve(function(t2) {
        try {
          var e2 = t2.querySelectorAll("svg"), r2 = [], o2 = function(t3, e3, n2) {
            if ("function" == typeof t3[a]) {
              var r3, o3, i3, u2 = t3[a]();
              if (function t4(n3) {
                try {
                  for (; !(r3 = u2.next()).done; )
                    if ((n3 = e3(r3.value)) && n3.then) {
                      if (!f(n3))
                        return void n3.then(t4, i3 || (i3 = l.bind(null, o3 = new c(), 2)));
                      n3 = n3.v;
                    }
                  o3 ? l(o3, 1, n3) : o3 = n3;
                } catch (t5) {
                  l(o3 || (o3 = new c()), 2, t5);
                }
              }(), u2.return) {
                var h2 = function(t4) {
                  try {
                    r3.done || u2.return();
                  } catch (t5) {
                  }
                  return t4;
                };
                if (o3 && o3.then)
                  return o3.then(h2, function(t4) {
                    throw h2(t4);
                  });
                h2();
              }
              return o3;
            }
            if (!("length" in t3))
              throw new TypeError("Object is not iterable");
            for (var d2 = [], s2 = 0; s2 < t3.length; s2++)
              d2.push(t3[s2]);
            return function(t4, e4, n3) {
              var r4, o4, i4 = -1;
              return function n4(u3) {
                try {
                  for (; ++i4 < t4.length; )
                    if ((u3 = e4(i4)) && u3.then) {
                      if (!f(u3))
                        return void u3.then(n4, o4 || (o4 = l.bind(null, r4 = new c(), 2)));
                      u3 = u3.v;
                    }
                  r4 ? l(r4, 1, u3) : r4 = u3;
                } catch (t5) {
                  l(r4 || (r4 = new c()), 2, t5);
                }
              }(), r4;
            }(d2, function(t4) {
              return e3(d2[t4]);
            });
          }(e2, function(t3) {
            function e3() {
              u2.dataset.icon = o3, u2.width = t3.clientWidth, u2.height = t3.clientHeight, t3.replaceWith(u2);
            }
            var o3 = t3.getAttribute("data-icon"), i3 = r2.find(function(t4) {
              return t4.dataIcon === o3;
            }), u2 = document.createElement("img"), a2 = function() {
              if (!i3)
                return Promise.resolve((0, import_save_svg_as_png.svgAsPngUri)(t3, "icon.png")).then(function(t4) {
                  u2.src = t4, r2.push({ dataIcon: o3, uri: t4 });
                });
              u2.src = i3.uri;
            }();
            return a2 && a2.then ? a2.then(e3) : e3();
          });
          return Promise.resolve(o2 && o2.then ? o2.then(function() {
          }) : void 0);
        } catch (t3) {
          return Promise.reject(t3);
        }
      }(t)).then(function() {
        return Promise.resolve(i2()).then(function() {
          return Promise.resolve(i2()).then(function(t2) {
            g2 = t2;
          });
        });
      });
    });
    return Promise.resolve(w2 && w2.then ? w2.then(m2) : m2());
  } catch (t2) {
    return Promise.reject(t2);
  }
};
var p = function(t, e, n2) {
  void 0 === n2 && (n2 = "png");
  var r2 = e.backgroundColor, i2 = e.quality, u2 = e.pixelRatio, a2 = e.style, l2 = o({}, function(t2, e2) {
    if (e2.width && e2.height)
      return { width: e2.width, height: e2.height };
    var n3 = window.getComputedStyle(t2), r3 = n3.height;
    return { width: Number.parseInt(n3.width.replace("px", ""), 10) + 4, height: Number.parseInt(r3.replace("px", ""), 10) + 4 };
  }(t, e), { pixelRatio: 1 });
  return a2 && (l2 = o({}, l2, { style: a2 })), r2 && (l2 = o({}, l2, { backgroundColor: r2 })), u2 && u2 > 0 && (l2 = o({}, l2, { pixelRatio: u2 })), i2 && n2.includes("jpeg") && (l2 = o({}, l2, { quality: i2 >= 0 && i2 <= 1 ? i2 : 1 })), l2 || {};
};
var g = function(e, n2, r2) {
  void 0 === n2 && (n2 = {}), void 0 === r2 && (r2 = {});
  try {
    return Promise.resolve(m(e, n2, function() {
      return toJpeg(e, o({ filter: y }, p(e, r2, "jpeg")));
    }, "jpeg")).then(function() {
    });
  } catch (t) {
    return Promise.reject(t);
  }
};
var w = function(t, n2, r2) {
  void 0 === n2 && (n2 = {}), void 0 === r2 && (r2 = {});
  try {
    return Promise.resolve(m(t, n2, function() {
      return toPng(t, o({ filter: y }, p(t, r2, "png")));
    }, "png")).then(function() {
    });
  } catch (t2) {
    return Promise.reject(t2);
  }
};
var b = function(t, e, n2) {
  void 0 === e && (e = "Image"), void 0 === n2 && (n2 = false);
  try {
    return Promise.resolve(w(t, { forceFixText: n2, filename: e })).then(function() {
    });
  } catch (t2) {
    return Promise.reject(t2);
  }
};
export {
  b as downloadDOM,
  g as saveAsJpeg,
  w as saveAsPng
};
//# sourceMappingURL=save-html-as-image.js.map
